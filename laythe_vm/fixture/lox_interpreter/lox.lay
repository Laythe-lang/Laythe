import std.env;
import std.io.stdio:{stdout, stderr, stdin};
import std.io.fs:{File};

// Lox interpreter written in ... Laythe!


// Scanner: converts Lox source code input into tokens

// One-character tokens (values are the ASCII codes)
let LEFT_PAREN = 40;
let RIGHT_PAREN = 41;
let LEFT_BRACE = 123;
let RIGHT_BRACE = 125;
let COMMA = 44;
let DOT = 46;
let MINUS = 45;
let PLUS = 43;
let SEMICOLON = 59;
let SLASH = 47;
let STAR = 42;
let BANG = 33;
let EQUAL = 61;
let GREATER = 62;
let LESS = 60;

// Two-character tokens
let BANG_EQUAL = 256;
let EQUAL_EQUAL = 257;
let GREATER_EQUAL = 258;
let LESS_EQUAL = 259;

// Literals
let IDENTIFIER = 260;
let STRING = 261;
let NUMBER = 262;

// Keywords
let AND = 263;
let CLASS = 264;
let ELSE = 265;
let FALSE = 266;
let FUN = 267;
let FOR = 268;
let IF = 269;
let NIL = 270;
let OR = 271;
let PRINT = 272;
let RETURN = 273;
let SUPER = 274;
let THIS = 275;
let TRUE = 276;
let VAR = 277;
let WHILE = 278;

// Misc tokens
let EOF = 279;
let INVALID = 280;

class Token {
  init(kind, value, line) {
    self.kind = kind;
    self.value = value;
    self.line = line;
  }
}

// Convert a token kind constant back to the source string that the
// token represents.
fn tokenTypeStr(kind) {
  if kind == LEFT_PAREN { return "("; }
  if kind == RIGHT_PAREN { return ")"; }
  if kind == LEFT_BRACE { return "{"; }
  if kind == RIGHT_BRACE { return "}"; }
  if kind == COMMA { return ","; }
  if kind == DOT { return "."; }
  if kind == MINUS { return "-"; }
  if kind == PLUS { return "+"; }
  if kind == SEMICOLON { return ";"; }
  if kind == SLASH { return "/"; }
  if kind == STAR { return "*"; }
  if kind == BANG { return "!"; }
  if kind == EQUAL { return "="; }
  if kind == GREATER { return ">"; }
  if kind == LESS { return "<"; }

  if kind == BANG_EQUAL { return "!="; }
  if kind == EQUAL_EQUAL { return "=="; }
  if kind == GREATER_EQUAL { return ">="; }
  if kind == LESS_EQUAL { return "<="; }

  if kind == IDENTIFIER { return "<identifier>"; }
  if kind == STRING { return "<string>"; }
  if kind == NUMBER { return "<number>"; }

  if kind == AND { return "and"; }
  if kind == CLASS { return "class"; }
  if kind == ELSE { return "else"; }
  if kind == FALSE { return "false"; }
  if kind == FUN { return "fun"; }
  if kind == FOR { return "for"; }
  if kind == IF { return "if"; }
  if kind == NIL { return "nil"; }
  if kind == OR { return "or"; }
  if kind == PRINT { return "print"; }
  if kind == RETURN { return "return"; }
  if kind == SUPER { return "super"; }
  if kind == THIS { return "self"; }
  if kind == TRUE { return "true"; }
  if kind == VAR { return "var"; }
  if kind == WHILE { return "while"; }

  if kind == EOF { return "<eof>"; }
  if kind == INVALID { return "<invalid>"; }

  return nil;
}

// Convert a keyword string to its token kind constant, || return nil
// if it's not a keyword.
fn keywordType(name) {
  if name == "and" { return AND; }
  if name == "class" { return CLASS; }
  if name == "else" { return ELSE; }
  if name == "false" { return FALSE; }
  if name == "fun" { return FUN; }
  if name == "for" { return FOR; }
  if name == "if" { return IF; }
  if name == "nil" { return NIL; }
  if name == "or" { return OR; }
  if name == "print" { return PRINT; }
  if name == "return" { return RETURN; }
  if name == "super" { return SUPER; }
  if name == "self" { return THIS; }
  if name == "true" { return TRUE; }
  if name == "var" { return VAR; }
  if name == "while" { return WHILE; }
  return nil;
}

fn isNameStart(ch) {
  return ch == '_' || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
}

fn isDigit(ch) {
  return ch >= '0' && ch <= '9';
}

class Scanner {
  init(source) {
    self.line = 1;
    self.buffered = nil;
    self.ch = -1;
    self.source = source.iter();
    self.advance();
  }

  advance() {
    let ch = self.ch;
    self.source.next();
    self.ch = self.source.current();
    return ch;
  }

  next() {
    // Support a one-character buffer for "123." use case to mimic Lox
    if self.buffered {
      let buffered = self.buffered;
      self.buffered = nil;
      return buffered;
    }


    while self.ch {
      let ch = self.advance();

      if ch == '(' { return Token(LEFT_PAREN, nil, self.line); }
      else if ch == ')' { return Token(RIGHT_PAREN, nil, self.line); }
      else if ch == '{' { return Token(LEFT_BRACE, nil, self.line); }
      else if ch == '}' { return Token(RIGHT_BRACE, nil, self.line); }
      else if ch == ',' { return Token(COMMA, nil, self.line); }
      else if ch == '.' { return Token(DOT, nil, self.line); }
      else if ch == '-' { return Token(MINUS, nil, self.line); }
      else if ch == '+' { return Token(PLUS, nil, self.line); }
      else if ch == ';' { return Token(SEMICOLON, nil, self.line); }
      else if ch == '*' { return Token(STAR, nil, self.line); }
      else if ch == '!' {
        if self.ch == '=' {
          self.advance();
          return Token(BANG_EQUAL, nil, self.line);
        }
        return Token(BANG, nil, self.line);
      }
      else if ch == '=' {
        if self.ch == '=' {
          self.advance();
          return Token(EQUAL_EQUAL, nil, self.line);
        }
        return Token(EQUAL, nil, self.line);
      }
      else if ch == '<' {
        if self.ch == '=' {
          self.advance();
          return Token(LESS_EQUAL, nil, self.line);
        }
        return Token(LESS, nil, self.line);
      }
      else if ch == '>' {
        if self.ch == '=' {
          self.advance();
          return Token(GREATER_EQUAL, nil, self.line);
        }
        return Token(GREATER, nil, self.line);
      }
      else if ch == '/' {
        if self.ch != '/' { return Token(SLASH, nil, self.line); }
        // Comment till end of line
        self.advance();

        // TODO escape sequence
        while self.ch && self.ch != '\n' {
          self.advance();
        }
        if self.ch == '\n' {
          self.line = self.line + 1;
        }
        self.advance();
      }
      // TODO escape sequence
      else if ch == ' ' || ch == '\t' || ch == '\r' {
        // Ignore whitespace: space, tab, and carriage return
      }
      else if ch == '\n' {
        // Newline
        self.line = self.line + 1;
      }
      else if ch == '"' {
        // Strings (start and end with double quote)
        let line = self.line;
        let value = "";
        while self.ch && self.ch != '"' {
          if self.ch == '\n' {
            self.line = self.line + 1;
          }
          value = value + self.ch;
          self.advance();
        }
        if !self.ch {
          return Token(INVALID, "Unterminated string.", self.line);
        }
        self.advance();
        return Token(STRING, value, line);
      }
      else if isDigit(ch) {
        // Numbers ('0' == 48)

        let num = ch;
        while isDigit(self.ch) {
          num = num + self.ch;
          self.advance();
        }

        // Fractional part
        if self.ch == DOT {
          num = num + self.ch;

          self.advance();
          if !isDigit(self.ch) {
            self.buffered = Token(DOT, nil, self.line);
            return Token(NUMBER, Number.parse(num), self.line);
          }

          while isDigit(self.ch) {
            num = num + self.ch;
            self.advance();
          }
        }
        return Token(NUMBER, Number.parse(num), self.line);
      }
      else if isNameStart(ch) {
        // Identifiers and keywords
        let name = ch;
        while isNameStart(self.ch) || isDigit(self.ch) {
          name = name + self.ch;
          self.advance();
        }
        let keyword = keywordType(name);
        if keyword {
          return Token(keyword, nil, self.line);
        }
        return Token(IDENTIFIER, name, self.line);
      }
      else {
        return Token(INVALID, 'Unexpected character "' + ch + '".' , self.line);
      }
    }
    return Token(EOF, nil, self.line);
  }
}

// Test scanner by reading input and displaying tokens
fn testScanner() {
  let scanner = Scanner();
  let done = false;
  while true {
    let token = scanner.next();
    if token.kind == EOF {
      break;
    } else if token.kind == INVALID {
      print(token.value + " on line:");
      print(token.line);
      break;
    } else {
      if token.value != nil {
        print(tokenTypeStr(token.kind));
        print(token.value);
      } else {
        print(tokenTypeStr(token.kind));
      }
    }
  }
}

// testScanner();


// Environment: used in interpreter to store and resolve variables.
class Environment {
  init(enclosing) {
    self.enclosing = enclosing;
    self.values = {};
  }

  // Find named value in environment, also looking in enclosing
  // environments. Exit with runtime error if name not found.
  get(name) {
    if self.values.has(name) {
      return self.values.get(name);
    }

    if self.enclosing {
      return self.enclosing.get(name);
    }

    runtimeError("Undefined variable '${name}'.");
  }

  // Assign an already-defined name in environment to value, also
  // looking in enclosing environments. Exit with runtime error if
  // name not found.
  assign(name, value) {
    if self.values.has(name) {
      self.values.set(name, value);
      return;
    }

    if self.enclosing != nil {
      self.enclosing.assign(name, value);
      return;
    }
    runtimeError("Undefined variable '${name}'.");
  }

  // Define a name in this environment and set to value.
  define(name, value) {
    self.values.set(name, value);
  }

  ancestor(distance) {
    let environment = self;
    for i in distance.times() {
      environment = environment.enclosing;
    }
    return environment;
  }

  getAt(distance, name) {
    return self.ancestor(distance).values.get(name);
  }

  assignAt(distance, name, value) {
    self.ancestor(distance).values.set(name, value);
  }
}


// Syntax tree nodes. Note that this is a NVAST (Not Very Abstract
// Syntax Tree :-), because each node includes a method to resolve
// and evaluate/execute itself. Done for simplicity.

// Expressions

class Assign {
  init(name, value) {
    self.kind = "Assign";
    self.name = name;
    self.value = value;
  }

  str() {
    return self.name + " = " + self.value.str();
  }

  resolve(resolver) {
    self.value.resolve(resolver);
    resolver.resolveVar(self, self.name);
  }

  evaluate(interpreter) {
    let value = self.value.evaluate(interpreter);
    let distance = interpreter.locals.get(self);
    if distance {
      interpreter.environment.assignAt(distance, self.name, value);
    } else {
      interpreter.globals.assign(self.name, value);
    }
    return value;
  }
}

class Binary {
  init(left, operator, right) {
    self.kind = "Binary";
    self.left = left;
    self.operator = operator;
    self.right = right;
  }

  resolve(resolver) {
    self.left.resolve(resolver);
    self.right.resolve(resolver);
  }

  str() {
    return "${self.left} ${tokenTypeStr(self.operator)} ${self.right}";
  }

  evaluate(interpreter) {
    let left = self.left.evaluate(interpreter);
    let right = self.right.evaluate(interpreter);
    if self.operator == PLUS { return left + right; }
    if self.operator == MINUS { return left - right; }
    if self.operator == STAR { return left * right; }
    if self.operator == SLASH { return left / right; }
    if self.operator == BANG_EQUAL { return left != right; }
    if self.operator == EQUAL_EQUAL { return left == right; }
    if self.operator == GREATER { return left > right; }
    if self.operator == GREATER_EQUAL { return left >= right; }
    if self.operator == LESS { return left < right; }
    if self.operator == LESS_EQUAL { return left <= right; }
    return nil; // Unreachable
  }
}

class Call {
  init(callee, arguments) {
    self.kind = "Call";
    self.callee = callee;
    self.arguments = arguments;
  }

  str() {
    let addComma = false;
    return self.arguments
      .iter()
      .reduce(self.callee.str() + "(", |s, argument| {
        if addComma {
          return s + ", ";
        }
        addComma = true;
        return s + argument.str();
      }) + ")";
  }

  resolve(resolver) {
    self.callee.resolve(resolver);
    self.arguments.iter().each(|argument| {
      argument.resolve(resolver);
    });
  }

  evaluate(interpreter) {
    let callee = self.callee.evaluate(interpreter);

    let arguments = self.arguments
      .iter()
      .map(|argument| argument.evaluate(interpreter))
      .into(List.collect);

    if arguments.len() != callee.arity() {
      runtimeError("Expected ${callee.arity()} arguments but got ${arguments.len()}.");
    }
    return callee.call(interpreter, arguments);
  }
}

class Get {
  init(object, name) {
    self.kind = "Get";
    self.object = object;
    self.name = name;
  }

  str() {
    return "${self.object}.${self.name}";
  }

  resolve(resolver) {
    self.object.resolve(resolver);
  }

  evaluate(interpreter) {
    let object = self.object.evaluate(interpreter);
    return object.get(self.name);
  }
}

class Grouping {
  init(expr) {
    self.kind = "Grouping";
    self.expr = expr;
  }

  str() {
    return "(${self.expr})";
  }

  resolve(resolver) {
    self.expr.resolve(resolver);
  }

  evaluate(interpreter) {
    return self.expr.evaluate(interpreter);
  }
}

class Literal {
  init(kind, value) {
    self.kind = "Literal";
    self.kind = kind;
    self.value = value;
  }

  str() {
    if self.kind == "boolean" {
      if self.value {
        return "true";
      } else {
        return "false";
      }
    }
    if self.kind == "nil" {
      return "nil";
    }
    if self.kind == "number" {
      return self.value.str();
    }
    if self.kind == "string" {
      return '"${self.value}"';
    }
    return "<unexpected kind>";
  }

  resolve(resolver) {
  }

  evaluate(interpreter) {
    return self.value;
  }
}

class Logical {
  init(left, operator, right) {
    self.kind = "Logical";
    self.left = left;
    self.operator = operator;
    self.right = right;
  }

  str() {
    return "${self.left} ${tokenTypeStr(self.operator)} ${self.right.str()}";
  }

  resolve(resolver) {
    self.left.resolve(resolver);
    self.right.resolve(resolver);
  }

  evaluate(interpreter) {
    let left = self.left.evaluate(interpreter);
    if self.operator == AND {
      return left && self.right.evaluate(interpreter);
    } else {
      return left || self.right.evaluate(interpreter);
    }
  }
}

class Set {
  init(object, name, value) {
    self.kind = "Set";
    self.object = object;
    self.name = name;
    self.value = value;
  }

  str() {
    return "${self.object}.${self.name} = ${self.value}";
  }

  resolve(resolver) {
    self.value.resolve(resolver);
    self.object.resolve(resolver);
  }

  evaluate(interpreter) {
    let object = self.object.evaluate(interpreter);
    let value = self.value.evaluate(interpreter);
    object.set(self.name, value);
    return value;
  }
}

class Super {
  init(method) {
    self.kind = "Super";
    self.method = method;
  }

  str() {
    return "super.${self.method}";
  }

  resolve(resolver) {
    resolver.resolveVar(self, "super");
  }

  evaluate(interpreter) {
    let distance = interpreter.locals.get(self);
    let superclass = interpreter.environment.getAt(distance, "super");
    let object = interpreter.environment.getAt(distance - 1, "this");
    let method = superclass.findMethod(object, self.method);
    if method == nil {
      runtimeError("Undefined property '${self.method}'.");
    }
    return method;
  }
}

class This {
  init() {
    self.kind = "This";
  }

  str() {
    return "this";
  }

  resolve(resolver) {
    resolver.resolveVar(self, "this");
  }

  evaluate(interpreter) {
    return interpreter.lookupVariable("this", self);
  }
}

class Unary {
  init(operator, right) {
    self.kind = "Unary";
    self.operator = operator;
    self.right = right;
  }

  str() {
    return "${tokenTypeStr(self.operator)}${self.right}";
  }

  resolve(resolver) {
    self.right.resolve(resolver);
  }

  evaluate(interpreter) {
    let right = self.right.evaluate(interpreter);
    if self.operator == BANG { return !right; }
    return -right;
  }
}

class Variable {
  init(name) {
    self.kind = "Variable";
    self.name = name;
  }

  str() {
    return self.name;
  }

  resolve(resolver) {
    if resolver.scopes.len() != 0 && resolver.scopes[resolver.scopes.len() - 1].get(self.name) == false {
      resolver.error("Error at '${self.name}': Cannot read local variable in its own initializer.");
    }

    resolver.resolveVar(self, self.name);
  }

  evaluate(interpreter) {
    let found = interpreter.lookupVariable(self.name, self);
    return found;
  }
}

// Statements

class Program {
  init(statements) {
    self.kind = "Program";
    self.statements = statements;
  }

  str() {
    return self.statements.iter().reduce("", |s, statement| {
      return s + statement.str();
    });
  }

  resolve(resolver) {
    for statement in self.statements {
      statement.resolve(resolver);
    }
  }

  execute(interpreter) {
    for statement in self.statements {
      statement.execute(interpreter);
    }
  }
}

let indent = 0;

class Block {
  init(statements) {
    self.kind = "Block";
    self.statements = statements;
  }

  str() {
    indent = indent + 1;
    let s = "{\n";

    let indentStr = indent.times()
      .reduce("", |indentStr, _| indentStr + "  ");

    s = self.statements
      .iter()
      .reduce(s, |s, statement| s + indentStr + statement.str());

    indent = indent - 1;

    indentStr = indent.times()
      .reduce("", |indentStr, _| indentStr + "  ");

    return s + indentStr + "}\n";
  }

  resolve(resolver) {
    resolver.beginScope();
    for statement in self.statements {
      statement.resolve(resolver);
    }
    resolver.endScope();
  }

  execute(interpreter) {
    return interpreter.executeBlock(self.statements, Environment(interpreter.environment));
  }
}

class Class {
  init(name, superclass, methods) {
    self.kind = "Class";
    self.name = name;
    self.superclass = superclass;
    self.methods = methods;
  }

  str() {
    let s = "class ${self.name} ";
    if self.superclass {
      s += "< ${self.superclass.name} ";
    }
    s += Block(self.methods).str(); // Reuse Block.str()
    return s;
  }

  resolve(resolver) {
    resolver.declare(self.name);
    if self.superclass {
      self.superclass.resolve(resolver);
    }
    resolver.define(self.name);
    if self.superclass {
      resolver.beginScope();
      resolver.scopes[resolver.scopes.len() - 1].set("super", true);
    }
    resolver.beginScope();
    resolver.scopes[resolver.scopes.len() - 1].set("this", true);

    self.methods.iter().each(|method| {
      resolver.resolveFunction(method);
    });

    resolver.endScope();
    if self.superclass != nil {
      resolver.endScope();
    }
  }

  execute(interpreter) {
    let superclass;
    if self.superclass {
      superclass = self.superclass.evaluate(interpreter);
      // The following will cause a runtime error if the superclass
      // is not a class
      superclass.findMethod;
    }
    interpreter.environment.define(self.name, nil);
    if self.superclass {
      interpreter.environment = Environment(interpreter.environment);
      interpreter.environment.define("super", superclass);
    }

    let methods = self.methods.iter().reduce({}, |methods, method| {
      let function = LoxFunction(method, interpreter.environment,
                                 method.name == "init");
      methods.set(method.name, function);
      return methods;
    });

    let klass = LoxClass(self.name, superclass, methods);
    if self.superclass != nil {
      interpreter.environment = interpreter.environment.enclosing;
    }
    interpreter.environment.assign(self.name, klass);
  }
}

class Expression {
  init(expression) {
    self.kind = "Expression";
    self.expression = expression;
  }

  str() {
    return "${self.expression};\n";
  }

  resolve(resolver) {
    self.expression.resolve(resolver);
  }

  execute(interpreter) {
    self.expression.evaluate(interpreter);
  }
}

class Function {
  init(name, params, body) {
    self.kind = "Function";
    self.name = name;
    self.params = params;
    self.body = body;
  }

  str() {
    let s = "fun ${self.name}(";
    let addComma = false;
    self.params.iter().reduce(s, |s, param| {
      if addComma {
        return s + ", ${param}";
      }
      addComma = true;
      return s + param;
    });

    return s + ") ${Block(self.body)}";
  }

  resolve(resolver) {
    resolver.declare(self.name);
    resolver.define(self.name);
    resolver.resolveFunction(self);
  }

  execute(interpreter) {
    let function = LoxFunction(self, interpreter.environment, false);
    interpreter.environment.define(self.name, function);
  }
}

class If {
  init(condition, thenBranch, elseBranch) {
    self.kind = "If";
    self.condition = condition;
    self.thenBranch = thenBranch;
    self.elseBranch = elseBranch;
  }

  str() {
    let s = "if (${self.condition}) ${self.thenBranch}";
    if self.elseBranch {
      for i in indent.times() {
        s += "  ";
      }
      s += "else ${self.elseBranch}";
    }
    return s;
  }

  resolve(resolver) {
    self.condition.resolve(resolver);
    self.thenBranch.resolve(resolver);
    if self.elseBranch {
      self.elseBranch.resolve(resolver);
    }
  }

  execute(interpreter) {
    if self.condition.evaluate(interpreter) {
      return self.thenBranch.execute(interpreter);
    }
    if self.elseBranch {
      return self.elseBranch.execute(interpreter);
    }
  }
}

class Print {
  init(expression) {
    self.kind = "Print";
    self.expression = expression;
  }

  str() {
    return "print ${self.expression};\n";
  }

  resolve(resolver) {
    self.expression.resolve(resolver);
  }

  execute(interpreter) {
    print(self.expression.evaluate(interpreter));
  }
}

class ReturnValue {
  init(value) {
    self.value = value;
  }
}

class Return {
  init(value) {
    self.kind = "Return";
    self.value = value;
  }

  str() {
    return "return ${self.value};\n";
  }

  resolve(resolver) {
    if self.value != nil {
      self.value.resolve(resolver);
    }
  }

  execute(interpreter) {
    let value;
    if self.value != nil {
      value = self.value.evaluate(interpreter);
    }
    return ReturnValue(value);
  }
}

class Var {
  init(name, initializer) {
    self.kind = "Var";
    self.name = name;
    self.initializer = initializer;
  }

  str() {
    let s = "var ${self.name}";
    if self.initializer {
      s += " = ${self.initializer}";
    }
    s += ";\n";
    return s;
  }

  resolve(resolver) {
    resolver.declare(self.name);
    if self.initializer {
      self.initializer.resolve(resolver);
    }
    resolver.define(self.name);
  }

  execute(interpreter) {
    let value;
    if self.initializer {
      value = self.initializer.evaluate(interpreter);
    }
    interpreter.environment.define(self.name, value);
  }
}

class While {
  init(condition, body) {
    self.kind = "While";
    self.condition = condition;
    self.body = body;
  }

  str() {
    return "while (${self.condition}) ${self.body}";
  }

  resolve(resolver) {
    self.condition.resolve(resolver);
    self.body.resolve(resolver);
  }

  execute(interpreter) {
    while self.condition.evaluate(interpreter) {
      let ret = self.body.execute(interpreter);
      if ret {
        return ret;
      }
    }
  }
}


// Lox runtime objects

class LoxFunction {
  init(declaration, closure, isInitializer) {
    self.declaration = declaration;
    self.closure = closure;
    self.isInitializer = isInitializer;
  }

  bind(instance) {
    let environment = Environment(self.closure);
    environment.define("this", instance);
    return LoxFunction(self.declaration, environment, self.isInitializer);
  }

  arity() {
    return self.declaration.params.len();
  }

  call(interpreter, arguments) {
    let environment = Environment(self.closure);

    self.declaration.params
      .iter()
      .zip(arguments.iter())
      .each(|items| {
        environment.define(items[0], items[1]);
      });

    let ret = interpreter.executeBlock(self.declaration.body, environment);
    if self.isInitializer {
      return self.closure.get("this");
    }
    if ret {
      return ret.value;
    }
    return nil;
  }
}

class LoxInstance {
  init(klass) {
    self.klass = klass;
    self.fields = {};
  }

  get(name) {
    if self.fields.has(name) {
      return self.fields.get(name);
    }
    let method = self.klass.findMethod(self, name);
    if method {
      return method;
    }

    print('sup');
    print(self.fields);
    runtimeError("Undefined property '${name}'.");
  }

  set(name, value) {
    self.fields.set(name, value);
  }
}

class LoxClass {
  init(name, superclass, methods) {
    self.name = name;
    self.superclass = superclass;
    self.methods = methods;
  }

  findMethod(instance, name) {
    let method = self.methods.get(name);
    if method {
      return method.bind(instance);
    }

    if self.superclass {
      return self.superclass.findMethod(instance, name);
    }
    return nil;
  }

  call(interpreter, arguments) {
    let instance = LoxInstance(self);
    let initializer = self.methods.get("init");
    if initializer {
      initializer.bind(instance).call(interpreter, arguments);
    }
    return instance;
  }

  arity() {
    let initializer = self.methods.get("init");
    if initializer {
      return initializer.arity();
    }
    return 0;
  }
}

class Builtin0 {
  init(f) {
    self.f = f;
  }

  arity() {
    return 0;
  }

  call(interpreter, arguments) {
    return self.f();
  }
}

class Builtin1 {
  init(f) {
    self.f = f;
  }

  arity() {
    return 1;
  }

  call(interpreter, arguments) {
    return self.f(arguments.get(0));
  }
}


// The parser

class Parser {
  init(source) {
    self.functionDepth = 0;
    self.classDepth = 0;
    self.token = nil;
    self.scanner = Scanner(source);
    self.previous = nil;
    self.inInitializer = nil;
    self.hasSuperClass = false;
    self.next();
  }

  next() {
    self.previous = self.token;
    self.token = self.scanner.next();
    if self.token.kind == INVALID {
      self.error(self.token, self.token.value);
    }
  }

  error(token, message) {
    let at;
    if token.kind == INVALID {
      at = "Error: ";
    } else if token.kind == EOF {
      at = "Error at end: ";
    } else if token.kind == IDENTIFIER {
      at = "Error at '${token.value}': ";
    } else if token.kind == NUMBER {
      at = "Error at '${token.value}': ";
    } else {
      at = "Error at '${tokenTypeStr(token.kind)}': ";
    }
    stderr.writeln("[line ${self.token.line}] ${at}${message}");
    exit(65);
  }

  match(kind) {
    if self.token.kind == kind {
      let previous = self.token;
      self.next();
      return previous;
    }
    return nil;
  }

  consume(kind, message) {
    let token = self.token;
    if self.match(kind) {
      return token;
    }
    self.error(self.token, message);
  }

  parse() {
    let statements = [];
    while self.token.kind != EOF {
      statements.push(self.declaration());
    }
    return Program(statements);
  }

  expression() {
    return self.assignment();
  }

  declaration() {
    if self.match(CLASS) { return self.classDeclaration(); }
    if self.match(FUN) { return self.function("function"); }
    if self.match(VAR) { return self.varDeclaration(); }
    return self.statement();
  }

  classDeclaration() {
    let name = self.consume(IDENTIFIER, "Expect class name.");
    let superclass;
    if self.match(LESS) {
      let superName = self.consume(IDENTIFIER, "Expect superclass name.");
      superclass = Variable(superName.value);
    }

    self.classDepth = self.classDepth + 1;
    self.hasSuperClass = superclass != nil;
    self.consume(LEFT_BRACE, "Expect '{' before class body.");
    let methods = [];
    while self.token.kind != EOF && self.token.kind != RIGHT_BRACE {
      methods.push(self.function("method"));
    }
    self.consume(RIGHT_BRACE, "Expect '}' after class body.");
    self.classDepth = self.classDepth - 1;
    self.hasSuperClass = false;

    return Class(name.value, superclass, methods);
  }

  statement() {
    if self.match(FOR) { return self.forStatement(); }
    if self.match(IF) { return self.ifStatement(); }
    if self.match(PRINT) { return self.printStatement(); }
    if self.match(RETURN) { return self.returnStatement(); }
    if self.match(WHILE) { return self.whileStatement(); }
    if self.match(LEFT_BRACE) { return Block(self.block()); }
    return self.expressionStatement();
  }

  forStatement() {
    self.consume(LEFT_PAREN, "Expect '(' after 'for'.");

    let initializer;
    if self.match(SEMICOLON) {
      // No initializer
    } else if self.match(VAR) {
      initializer = self.varDeclaration();
    } else {
      initializer = self.expressionStatement();
    }

    let condition;
    if self.token.kind != SEMICOLON {
      condition = self.expression();
    }
    self.consume(SEMICOLON, "Expect ';' after loop condition.");

    let increment;
    if self.token.kind != RIGHT_PAREN {
      increment = Expression(self.expression());
    }
    self.consume(RIGHT_PAREN, "Expect ')' after for clauses.");

    let body = self.statement();

    // Desugar increment
    if increment {
      let statements = [];
      statements.push(body);
      statements.push(increment);
      body = Block(statements);
    }

    // Desugar condition
    if condition == nil {
      condition = Literal("boolean", true);
    }
    body = While(condition, body);

    // Desugar initializer
    if initializer {
      let statements = [];
      statements.push(initializer);
      statements.push(body);
      body = Block(statements);
    }

    return body;
  }

  ifStatement() {
    self.consume(LEFT_PAREN, "Expect '(' after 'if'.");
    let condition = self.expression();
    self.consume(RIGHT_PAREN, "Expect ')' after if condition.");
    let thenBranch = self.statement();
    let elseBranch;
    if self.match(ELSE) {
      elseBranch = self.statement();
    }
    return If(condition, thenBranch, elseBranch);
  }

  printStatement() {
    let value = self.expression();
    self.consume(SEMICOLON, "Expect ';' after value.");
    return Print(value);
  }

  returnStatement() {
    if self.functionDepth <= 0 {
      self.error(self.previous, "Cannot return from top-level code.");
    }
    let value;
    if self.token.kind != SEMICOLON {
      if self.inInitializer {
        self.error(self.previous, "Cannot return a value from an initializer.");
      }
      value = self.expression();
    }
    self.consume(SEMICOLON, "Expect ';' after return value.");
    return Return(value);
  }

  varDeclaration() {
    let name = self.consume(IDENTIFIER, "Expect letiable name.");
    let initializer;
    if self.match(EQUAL) {
      initializer = self.expression();
    }
    self.consume(SEMICOLON, "Expect ';' after variable declaration.");
    return Var(name.value, initializer);
  }

  whileStatement() {
    self.consume(LEFT_PAREN, "Expect '(' after 'while'.");
    let condition = self.expression();
    self.consume(RIGHT_PAREN, "Expect ')' after condition.");
    let body = self.statement();
    return While(condition, body);
  }

  expressionStatement() {
    let expr = self.expression();
    self.consume(SEMICOLON, "Expect ';' after expression.");
    return Expression(expr);
  }

  function(kind) {
    let name = self.consume(IDENTIFIER, "Expect ${kind} name.");
    self.consume(LEFT_PAREN, "Expect '(' after ${kind} name.");
    let parameters = [];
    let n = 0;
    while self.token.kind != RIGHT_PAREN {
      if n > 0 {
        self.consume(COMMA, "Expect ')' after parameters.");
      }
      if n >= 8 {
        self.error(self.token, "Cannot have more than 8 parameters.");
      }
      let paramName = self.consume(IDENTIFIER, "Expect parameter name.");
      parameters.push(paramName.value);
      n = n + 1;
    }
    self.consume(RIGHT_PAREN, "Expect ')' after parameters.");
    self.consume(LEFT_BRACE, "Expect '{' before " + kind + " body.");

    self.functionDepth = self.functionDepth + 1;
    self.inInitializer = kind == "method" && name.value == "init";
    let body = self.block();
    self.functionDepth = self.functionDepth - 1;
    self.inInitializer = false;

    return Function(name.value, parameters, body);
  }

  block() {
    let statements = [];
    while self.token.kind != EOF && self.token.kind != RIGHT_BRACE {
      statements.push(self.declaration());
    }
    self.consume(RIGHT_BRACE, "Expect '}' after block.");
    return statements;
  }

  assignment() {
    let expr = self.or_();
    if self.match(EQUAL) {
      let equals = self.previous;
      let value = self.assignment();
      if expr.kind == "Variable" {
        return Assign(expr.name, value);
      }
      if expr.kind == "Get" {
        return Set(expr.object, expr.name, value);
      }
      self.error(equals, "Invalid assignment target.");
    }
    return expr;
  }

  or_() {
    let expr = self.and_();
    while self.match(OR) {
      let right = self.and_();
      expr = Logical(expr, OR, right);
    }
    return expr;
  }

  and_() {
    let expr = self.equality();
    while self.match(AND) {
      let right = self.equality();
      expr = Logical(expr, AND, right);
    }
    return expr;
  }

  equality() {
    let expr = self.comparison();
    while self.token.kind == BANG_EQUAL || self.token.kind == EQUAL_EQUAL {
      let operator = self.token.kind;
      self.next();
      let right = self.comparison();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  comparison() {
    let expr = self.addition();
    while (self.token.kind == GREATER || self.token.kind == GREATER_EQUAL ||
           self.token.kind == LESS || self.token.kind == LESS_EQUAL) {
      let operator = self.token.kind;
      self.next();
      let right = self.addition();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  addition() {
    let expr = self.multiplication();
    while self.token.kind == MINUS || self.token.kind == PLUS {
      let operator = self.token.kind;
      self.next();
      let right = self.multiplication();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  multiplication() {
    let expr = self.unary();
    while self.token.kind == SLASH || self.token.kind == STAR {
      let operator = self.token.kind;
      self.next();
      let right = self.unary();
      expr = Binary(expr, operator, right);
    }
    return expr;
  }

  unary() {
    if self.token.kind == BANG || self.token.kind == MINUS {
      let operator = self.token.kind;
      self.next();
      let right = self.unary();
      return Unary(operator, right);
    }
    return self.call();
  }

  call() {
    let expr = self.primary();
    let loop = true;
    while loop {
      if self.match(LEFT_PAREN) {
        let arguments = [];
        let n = 0;
        while self.token.kind != RIGHT_PAREN {
          if n > 0 {
            self.consume(COMMA, "Expect ')' after arguments.");
          }
          if n >= 8 {
            self.error(self.token, "Cannot have more than 8 arguments.");
          }
          arguments.push(self.expression());
          n = n + 1;
        }
        self.consume(RIGHT_PAREN, "Expect ')' after arguments.");
        expr = Call(expr, arguments);
      } else if self.match(DOT) {
        let name = self.consume(IDENTIFIER, "Expect property name after '.'.");
        expr = Get(expr, name.value);
      } else {
        loop = false;
      }
    }
    return expr;
  }

  primary() {
    if self.match(FALSE) { return Literal("boolean", false); }
    if self.match(TRUE) { return Literal("boolean", true); }
    if self.match(NIL) { return Literal("nil", nil); }
    let number = self.match(NUMBER);
    if number {
      return Literal("number", number.value);
    }
    let string = self.match(STRING);
    if string {
      return Literal("string", string.value);
    }
    if self.match(SUPER) {
      if self.classDepth <= 0 {
        self.error(self.previous, "Cannot use 'super' outside of a class.");
      }
      if !self.hasSuperClass {
        self.error(self.previous, "Cannot use 'super' in a class with no superclass.");
      }
      self.consume(DOT, "Expect '.' after 'super'.");
      let method = self.consume(IDENTIFIER, "Expect superclass method name.");
      return Super(method.value);
    }
    if self.match(THIS) {
      if self.classDepth <= 0 {
        self.error(self.previous, "Cannot use 'this' outside of a class.");
      }
      return This();
    }
    let identifier = self.match(IDENTIFIER);
    if identifier {
      return Variable(identifier.value);
    }
    if self.match(LEFT_PAREN) {
      let expr = self.expression();
      self.consume(RIGHT_PAREN, "Expect ')' after expression.");
      return Grouping(expr);
    }
    self.error(self.token, "Expect expression.");
  }
}


// The variable resolver

class Resolver {
  init(program, interpreter) {
    self.program = program;
    self.interpreter = interpreter;
    self.scopes = []; // List can be used as a stack too
  }

  error(message) {
    stderr.writeln("[line 1] ${message}"); // This is hack for tests (it's not always line 1)
    exit(65);
  }

  resolve() {
    self.program.resolve(self);
  }

  resolveFunction(function) {
    self.beginScope();
    for param in function.params {
      self.declare(param);
      self.define(param);
    }

    for statement in function.body {
      statement.resolve(resolver);
    }
    self.endScope();
  }

  beginScope() {
    self.scopes.push({});
  }

  endScope() {
    self.scopes.pop();
  }

  declare(name) {
    if self.scopes.len() == 0 {
      return;
    }
    let scope = self.scopes[self.scopes.len() - 1];
    if scope.has(name) {
      self.error("Error at '${name}': Variable with this name already declared in this scope.");
    }
    scope.set(name, false);
  }

  define(name) {
    if self.scopes.len() == 0 {
      return;
    }
    self.scopes[self.scopes.len() - 1].set(name, true);
  }

  resolveVar(expr, name) {

    for i in self.scopes.len().times() {
      if self.scopes[i].has(name) {
        self.interpreter.resolve(expr, self.scopes.len() - 1 - i);
        return;
      }
    }
    // Not found, assume it's a global

  }
}


// The tree-walking interpreter

fn defaultGlobals() {
  let globals = Environment(nil);

  // Define built-in functions
  globals.define("clock", Builtin0(clock));
  globals.define("exit", Builtin1(exit));
  globals.define("print_error", Builtin1(print_error));

  return globals;
}

class Interpreter {
  init(program, globals) {
    self.program = program;
    self.globals = globals;
    self.environment = globals;
    self.locals = {};
  }

  static default(program) {
    return Interpreter(program, defaultGlobals());
  }

  interpret() {
    self.program.execute(self);
  }

  executeBlock(statements, environment) {
    let previous = self.environment;
    self.environment = environment;
    let ret;

    for statement in statements {
      ret = statement.execute(self);

      if ret {
        break;
      }
    }

    self.environment = previous;
    return ret;
  }

  resolve(expr, depth) {
    self.locals.set(expr, depth);
  }

  lookupVariable(name, expr) {
    let distance = self.locals.get(expr);
    if distance {
      return self.environment.getAt(distance, name);
    } else {
      return self.globals.get(name);
    }
  }
}

fn runtimeError(message) {
  stderr.writeln(message);
  // stderr.writeln("[line 1]"); // This is hack for tests (it's not always line 1)
  exit(70);
}

fn print_error(message) {
  stderr.writeln(message);
}

let args = env.args();
let parser;
let resolver;
let interpreter;


if args.len() < 3 {
  // do repl

  let globals = defaultGlobals();
  while true {
    stdout.write('lox:> ');
    stdout.flush();
    let line = stdin.readLine();

    parser = Parser(line);
    let program = parser.parse();

    // Uncomment these two lines to pretty-print the parsed syntax tree
    // print(program.str());
    // print("-----");

    interpreter = Interpreter(program, globals);
    resolver = Resolver(program, interpreter);
    resolver.resolve();
    interpreter.interpret();

    globals = interpreter.globals;
  }
} else {
  let filePath = args[2];

  parser = Parser(File.readAllText(filePath));
  let program = parser.parse();

  // Uncomment these two lines to pretty-print the parsed syntax tree
  print(program.str());
  print("-----");

  interpreter = Interpreter.default(program);
  resolver = Resolver(program, interpreter);
  resolver.resolve();
  interpreter.interpret();
}


